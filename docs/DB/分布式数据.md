# 分布式数据

# 全局唯一ID



## 概述

* 全局唯一性,不可出现重复id数据
* 需要防止恶意用户根据id规则来获取数据
* 保证下一个id一定大于上一个id



## 实现方式

### UUID

* 优点:代码实现简单,不占用宽带,数据迁移不受影响
* 缺点:无序,无法保证递增趋势,字符存储,传输以及查询慢,不可读



### SnowFlake

* 雪花算法,实现方式是用64位的二进制分别表示不同的含义:
  * 从左到右的第1位为0,固定
  * 第2位到42位,总共41位,表示二进制的毫秒时间戳
  * 第43位到47位,总共5位,表示二进制的机房编号
  * 第48位到52位,总共5位,表示二进制的机器编号
  * 第53位到64位,总共12位,表示二进制的数据编号,顺序生成
* 优点:代码实现简单,不占用宽带,数据迁移不受影响,低位趋势递增
* 缺点:强依赖时钟(多台服务器时间一定要一样),无序无法保证趋势递增



### Redis

* 集群缩减版本:年份+当前这天属于这一年的第多少天+小时+redis自增:2+3+2+6=13位.调用intr方法

* 优点:不依赖数据,灵活方便,性能优于数据库自增长,没有单点故障
* 缺点:需要占用网络资源,性能要比本地生成慢,需要增加redis集群



### Zookeeper

* 集群环境下生成方式同Redis,调用的是InterProcessMutex方法
* 优缺点同Redis差不多



# 分布式锁

## Redis

* nx方法,若key存在则返回nil,若key不存在则设置值
* 需要使用到特定的脚本才行,详见官网的set方法



## Redisson

* Redis封装的专门用于分布式的各种锁,信号量等机制的框架



## Zookeeper

* 临时节点的新增删除,集群中同一时间只能有一个节点进行新增



# 分布式事务



## 两阶段提交/XA



* 两阶段提交,有一个事务管理器,管理器负责协调多个数据库的事务
* 事务管理器先访问各个数据库操作是否成功,如果每个数据库都回复ok,那么就正式提交事务
* 如果任何一个数据库回答不ok,那么就回滚事务
* 这种分布式事务方案,比较适合单块应用里,跨多个库的分布式事务
* 因为严重依赖于数据库层面来搞定复杂的事务,效率很低,绝对不适合高并发的场景
* 基于spring + JTA的组合可以实现该事务
* 若某个系统内部出现跨多个库的操作,是不合规的,应该每个服务只操作自己对应点数据库
* 若需要操作别的服务对应的库,不允许直连别的服务的库,违反微服务架构的规范
* 若随意交叉访问,服务是没法管理的,数据可能经常被别人改错,自己的库被别人写挂
* 若要操作别人的服务的库,必须通过调用该服务的接口来实现,绝对不允许交叉访问别人的数据



## TCC

 ![](TCC.png)

* TCC的全称是:Try->Confirm->Cancel
* 这个其实是用到了补偿的概念,分为了三个阶段:
  * Try阶段:对各个服务的资源做检测以及对资源进行锁定或者预留
  * Confirm阶段:在各个服务中执行实际的操作
  * Cancel阶段:若任何一个服务的业务方法出错,就需要进行补偿,将已经执行成功的业务逻辑回滚
* 例如跨银行银行转账,若用TCC方案解决如下
  * Try阶段:先把两个银行账户中的资金给它冻结住就不让操作了
  * Confirm阶段:执行实际的转账操作,A银行账户的资金扣减,B银行账户的资金增加
  * Cancel阶段:若任何一个银行的操作失败,就需要回滚进行补偿.比如A银行账户如果已经扣减了,但是B银行账户资金增加失败了,那么就得把A银行账户资金给加回去
* 这种方案几乎很少使用,因为这个事务回滚严重依赖于自己写代码来回滚和补偿,会造成补偿代码巨大
* 一般来说跟钱相关的,支付,交易相关的场景,可以用TCC,严格保证分布式事务要么全部成功,要么全部自动回滚



## 本地消息表



* A系统在自己本地一个事务里操作,同时插入一条数据到消息表,接着A系统将这个消息发送到MQ中去
* B系统接收到消息之后,在一个事务里,往自己本地消息表里插入一条数据,同时执行其他的业务操作,如果这个消息已经被处理过了,那么此时这个事务会回滚,这样保证不会重复处理消息
* B系统执行成功之后,就会更新自己本地消息表的状态以及A系统消息表的状态
* 如果B系统处理失败了,那么就不会更新消息表状态,那么此时A系统会定时扫描自己的消息表,如果有没处理的消息,会再次发送到MQ中去,让B再次处理
* 这个方案保证了最终一致性,哪怕B事务失败了,但是A会不断重发消息,直到B成功为止
* 这个方案最大的问题就在于严重依赖于数据库的消息表来管理事务.完全无法胜任高并发场景,也不好扩展

 

## 可靠消息最终一致性

 

* 不用本地的消息表,直接基于MQ来实现事务
* A系统先发送一个prepared消息到mq,如果这个prepared消息发送失败那么就直接取消操作别执行了
* 如果这个消息发送成功了,接着执行本地事务.成功则告诉mq发送确认消息,失败则告诉mq回滚消息
* 如果发送了确认消息,那么此时B系统会接收到确认消息,然后执行本地的事务
* mq会自动定时轮询所有prepared消息回调接口,确认本地事务处理是否失败.若失败,是继续重试还是回滚
* 该方案里,若B服务的事务失败了如何解决:
  * 重试,自动不断重试直到成功,最好设置重试次数,尽量不影响业务的正常运行
  * 实在无法成功,事务回滚.比如B系统本地回滚后,通知系统A也回滚;或者发送报警手工回滚和补偿
* 这个还是比较合适的,但是会存在资源浪费



## 最大努力通知



* 系统A本地事务执行完之后,发送个消息到MQ
* 这里会有个专门消费MQ的最大努力通知服务,这个服务会消费MQ然后写入数据库中记录下来,或者是放入个内存队列也可以,接着调用系统B的接口
* 要是系统B执行成功就ok了,要是系统B执行失败了,那么最大努力通知服务就定时尝试重新调用系统B,反复N次,最后还是不行就放弃



# Seata

* 阿里的分布式事务框架,支持AT,XA,TCC等,详见官网



# TCC-Transaction



# ByteTCC